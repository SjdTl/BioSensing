import numpy as np
import pandas as pd
import os
from scipy.signal import butter, filtfilt

from . import feat_gen 

def EMG(unprocessed_emg, fs = 700):
    """
    Description
    -----------
    Obtains the features for an emg window of x seconds.

    Parameters
    ----------
    unprocessed_emg : np.array
        emg signal as provided directly by the sensors
    fs : int or float
        sampling frequency of the sensors

    Returns
    -------
    features : pd.DataFrame
        Dataframe (1 row) containing the features:\n
            - WL: waveform length \n
            - MAL: overall muscle activity level (RMS)\n
            - MCI: muscle contraction intensity (average absolute amplitude)\n
            - SSC: slope sign change (number of time slope of the EMG signal changes sign)\n
            and the general features:\n
            - Mean (no meaning in the case of emg)\n
            - Median\n
            - Std\n
            - ...\n
     
    Raises
    ------
    ValueError
        Raises error if there is a NaN value in the features
    
    Notes
    -----
    
    Examples
    --------
    >>>
    """

    emg = preProcessing(unprocessed_emg, fs)

    df_specific = EMG_specific_features(emg)
    # General features contain mean emg, but this has no meaning in the case of emg
    df_general = feat_gen.basic_features(emg, "EMG")

    features = pd.concat([df_specific, df_general], axis=1)

    # Error messages
    if features.isnull().values.any():
        raise ValueError("The feature array of EMG contains a NaN value")
    return features

def EMG_specific_features(emg):
    """
    Description
    -----------
    Calculate features specific to emg signal

    Parameters
    ----------
    emg : np.array
        processed emg data as provided by the sensors
    
    Returns
    -------
    out : pd.DataFrame
        dataframe containing the features mentioned in the docstring of EMG()
    
    Raises
    ------
    error
         description
    
    Notes
    -----
    """

    out_dict = {}
    # Waveform length
    out_dict["WL"] = np.sum(emg[1:]-emg[:-1])
    # SLope sign change
    epsilon = 100 * 10**(-6) # should be changed someday
    out_dict["SSC"] = np.count_nonzero((emg[1:-1]-emg[:-2])*(emg[1:-1]-emg[2:]) > epsilon)
    # Overall muscle activity level: RMS is a measure of the amplitude of the EMG signal and reflects the overall muscle activity level
    out_dict["MAL"] = feat_gen.rms(emg)
    # MAV represents the average absolute amplitude of the EMG signal and is sensitive to muscle contraction intensity
    out_dict["MCI"] = np.mean(np.abs(emg))
    
    # Turn dictionary into pd.DataFrame and return
    return pd.DataFrame.from_dict(out_dict, orient="index").T.add_prefix("EMG_")

def preProcessing(emg, fs=700):
    """
    Description
    -----------
    Preprocessing of EMG signal by bandpass filtering and removing DC value

    Parameters
    ----------
    emg : np.array
        emg signal as provided directly by the sensors
    fs : int or string
        Sampling rate of the sensors
    
    Returns
    -------
    out : np.array
        processed EMG signal
    
    Raises
    ------
    error
         description
    
    Notes
    -----
    
    """

    # Apply bandpass filter (10-300 Hz):
    filtered_emg = butter_bandpass_filter(emg, 10, 300, fs, 4)
    # Correct baseline
    baseline = np.mean(filtered_emg)
    return filtered_emg - baseline

def envolope_emg(emg, fs=700):
    """
    Description
    -----------
    Here we perform signal rectification to focus on the magnitude of muscle activity.

    To investigate muscle force and muscle activity, scientist often use a low pass filter to capture the shape or “envelope” of the EMG signal as this is thought to better reflect force generated by a muscle.  

    Parameters
    ----------
    emg : np.array
        processed EMG signal
    fs : int or float
        sampling frequency
    
    Returns
    -------
    emg_envelope : np.array
        Rectified and low-pass filtered emg signal
    
    Notes
    -----
    Not yet used 
    """

    emg_rec = np.abs(emg)
    low_pass= 3 /(fs/2)
    b2, a2 = butter(4, low_pass, btype='low')
    emg_envelope = filtfilt(b2, a2, emg_rec)
    return emg_envelope

def butter_bandpass(lowcut, highcut, fs, order=4):
    """
    Description
    -----------
    Provided polynomials of a butterworth IIR filter

    Parameters
    ----------
    lowcut, highcut: float
        bandpass frequencies
    fs : float
        sampling frequency
    order : int
        order of butterworth filter
    
    Returns
    -------
    b,a : type
         Numerator (b) and denominator (a) polynomials of the IIR filter
    
    
    Notes
    -----
    Not yet clear if butterworth is the best filter for this
    """

    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='bandpass')
    return b, a

def butter_bandpass_filter(data, lowcut, highcut, fs, order=4):
    """
    Apply a butterworth bandpass filter. See butter_bandpass for description
    """
    b, a = butter_bandpass(lowcut, highcut, fs, order)
    y = filtfilt(b,a, data)
    return y

def test(filepath):
    """
    Description
    -----------
    Function to test the signal, without having to call the entire database. Please use this function when looking for data to plot for the report.
    
    Parameters
    ----------
    Filepath: string
        Filepath to the test signal. This should be a pickled dictionary with the following format:
            dict = {EDA: [..]
                    EMG: [..]
                    ECG: [..]}
        Each signal is of one person, one label and includes only a small timeframe
    Returns
    -------
    df: pd.DataFrame
        Dataframe containing the features 
        
    """
    emg = feat_gen.load_test_data("EMG", filepath)

    # feat_gen.quick_plot(emg, preProcessing(emg), envolope_emg(emg))

    df = EMG(emg, 700)
    return df

# dir_path = os.path.dirname(os.path.realpath(__file__))
# filepath = os.path.join(dir_path, "Raw_data", "raw_small_test_data.pkl")
# print(test(filepath))