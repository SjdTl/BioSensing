import numpy as np
import pandas as pd
import os
from scipy.signal import butter, filtfilt

import all_signals

def EMG(unprocessed_emg, fs = 700):
    """
    Description
    -----------
    Obtains the features for an emg window of x seconds.

    Parameters
    ----------
    unprocessed_emg : np.array
        emg signal as provided directly by the sensors
    fs : int or float
        sampling frequency of the sensors

    Returns
    -------
    features : pd.DataFrame
        Dataframe (1 row) containing the features:
            - WL: waveform length
            - MAL: overall muscle activity level (RMS)
            - MCI: muscle contraction intensity (average absolute amplitude)
            - SSC: slope sign change (number of time slope of the EMG signal changes sign)
            and the general features:
            - Mean (no meaning in the case of emg)
            - Median
            - Std
            - ...
     
    Raises
    ------
    ValueError
        Raises error if there is a NaN value in the features
    
    Notes
    -----
    
    Examples
    --------
    >>>
    """

    emg = preProcessing(unprocessed_emg, fs)

    df_specific = EMG_specific_features(emg)
    # General features contain mean emg, but this has no meaning in the case of emg
    df_general = all_signals.basic_features(emg, "emg")

    features = pd.concat([df_specific, df_general], axis=1)

    # Error messages
    if features.isnull().values.any():
        raise ValueError("The feature array of EMG contains a NaN value")
    return features

def EMG_specific_features(emg):
    """
    Description
    -----------
    Calculate features specific to emg signal

    Parameters
    ----------
    emg : np.array
        processed emg data as provided by the sensors
    
    Returns
    -------
    out : pd.DataFrame
        dataframe containing the features mentioned in the docstring of EMG()
    
    Raises
    ------
    error
         description
    
    Notes
    -----
    """
    
    # Waveform length
    WL = np.sum(emg[1:]-emg[:-1])
    # SLope sign change
    epsilon = 100 * 10**(-6) # should be changed someday
    SSC = np.count_nonzero((emg[1:-1]-emg[:-2])*(emg[1:-1]-emg[2:]) > epsilon)
    # Overall muscle activity level: RMS is a measure of the amplitude of the EMG signal and reflects the overall muscle activity level
    MAL = all_signals.rms(emg)
    # MAV represents the average absolute amplitude of the EMG signal and is sensitive to muscle contraction intensity
    MCI = np.mean(np.abs(emg))

    # Create dictionary
    features = {"WL_emg" : [WL], 
                "SSC_emg" : [SSC],
                "MAL_emg" : [MAL],
                "MCI_emg" : [MCI]}
    
    # Turn dictionary into pd.DataFrame and return
    return pd.DataFrame(features)

def preProcessing(emg, fs=700):
    """
    Description
    -----------
    Preprocessing of EMG signal by bandpass filtering and removing DC value

    Parameters
    ----------
    emg : np.array
        emg signal as provided directly by the sensors
    fs : int or string
        Sampling rate of the sensors
    
    Returns
    -------
    out : np.array
        processed EMG signal
    
    Raises
    ------
    error
         description
    
    Notes
    -----
    
    """

    # Apply bandpass filter (10-300 Hz):
    filtered_emg = butter_bandpass_filter(emg, 10, 300, fs, 4)
    # Correct baseline
    baseline = np.mean(filtered_emg)
    return filtered_emg - baseline

def envolope_emg(emg, fs=700):
    """
    Description
    -----------
    Here we perform signal rectification to focus on the magnitude of muscle activity.

    To investigate muscle force and muscle activity, scientist often use a low pass filter to capture the shape or “envelope” of the EMG signal as this is thought to better reflect force generated by a muscle.  

    Parameters
    ----------
    emg : np.array
        processed EMG signal
    fs : int or float
        sampling frequency
    
    Returns
    -------
    emg_envelope : np.array
        Rectified and low-pass filtered emg signal
    
    Notes
    -----
    Not yet used 
    """

    emg_rec = np.abs(emg)
    low_pass= 3 /(fs/2)
    b2, a2 = butter(4, low_pass, btype='low')
    emg_envelope = filtfilt(b2, a2, emg_rec)
    return emg_envelope

def butter_bandpass(lowcut, highcut, fs, order=4):
    """
    Description
    -----------
    Provided polynomials of a butterworth IIR filter

    Parameters
    ----------
    lowcut, highcut: float
        bandpass frequencies
    fs : float
        sampling frequency
    order : int
        order of butterworth filter
    
    Returns
    -------
    b,a : type
         Numerator (b) and denominator (a) polynomials of the IIR filter
    
    
    Notes
    -----
    Not yet clear if butterworth is the best filter for this
    """

    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='bandpass')
    return b, a

def butter_bandpass_filter(data, lowcut, highcut, fs, order=4):
    """
    Apply a butterworth bandpass filter. See butter_bandpass for description
    """
    b, a = butter_bandpass(lowcut, highcut, fs, order)
    y = filtfilt(b,a, data)
    return y

def test():
    """
    Description
    -----------
    Function to test the signal, without having to call the entire database. Please use this function when looking for data to plot for the report.
    
    Notes
    -----
    Returns and takes nothing
    """

    dir_path = os.path.dirname(os.path.realpath(__file__))
    filename = os.path.join(dir_path, "Raw_data", "raw_small_test_data.pkl")
    emg = all_signals.load_test_data("EMG", filename)

    all_signals.quick_plot(emg)

    df = EMG(emg, 700)
    print(df)